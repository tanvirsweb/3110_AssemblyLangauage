.MODEL SMALL
.STACK 100H
.DATA  
 MSG_INP DB "ENTER A DECIMAL NUMBER:$",0DH,0AH 
 STR_PRIME DB "PRIME$",0DH,0AH
 STR_NONPRIME DB "NOT PRIME$",ODH,OAH
 
.CODE  

INDEC PROC
;INPUT:NONE
;OUTPUT: AX=BINARY EQUIVALENT OF NUMBER
    PUSH BX
    PUSH CX
    PUSH DX
;PRINT PROMT
@BEGIN:
    MOV AH,2
    MOV DL,'?'
    INT 21H
;BX=TOTAL=0
    XOR BX,BX
;CX=NEGATIVE=FALSE
    XOR CX,CX
;READ A CHARACTER  
    MOV AH,1
    INT 21H
;CASE CHARACTER OF
    CMP AL,'-'     ;MINUS SIGN?
    JE @MINUS      ;YES->SET SIGN
    CMP AL,'+'     ;PLUS SIGN        
    JE @PLUS
    JMP @REPEAT2
@MINUS:
    MOV CX,1
@PLUS:
    INT 21H
;END CASE
@REPEAT2:
;IF CHARACTER IS BETWEEN '0' AND '9'
    CMP AL,'0'
    JNGE @NOT_DIGIT;        ILLEGAL CHARACTER
    CMP AL,'9'
    JNLE @NOT_DIGIT;        ILLEGAL CHARACTER
    
;CONVERT CHARACTER TO DIGIT
    AND AX,000FH
    PUSH AX
;TOTAL=TOTAL*10+DIGIT
    MOV AX,10
    MUL BX          ;AX=TOTAL*10 
    POP BX
    ADD BX,AX       ;TOTAL= TOTAL*10+DIGIT
;READ CHARACTER

    MOV AH,1
    INT 21H
    CMP AL,0DH      ;CARRIAGE RETURN
    JNE @REPEAT2    ;NO,KEEP GOING
;UNTIL CR
    MOV AX,BX      ;STORE NUMBER IN AX
;IF NEGATIVE 
    OR CX,CX       ;NEGATIVE NUMBER
    JE @EXIT       ;NO,EXIT
;THEN
    NEG AX          ;YES NEGATE
;END_IF
@EXIT:
MOV AH,2        ;MOVE CURSOR TO A NEW LINE    
    POP DX          ;RESTORE REGISTERS
    POP CX
    POP BX
    RET             ;AND RETURN
;HERE IF ILLEGAL CHARACTER ENTERED
@NOT_DIGIT:
    MOV AH,2        ;MOVE CURSOR TO A NEW LINE
    MOV DL,0DH
    INT 21H                                                 
    MOV DL,0AH
    INT 21H
    JMP @BEGIN      ;GOTO BEGINING
    
INDEC ENDP  


OUTDEC PROC
;PRINT AX AS A SGNED DECIMAL INTEGER
;INPUT: AX
;OUTPUT: NONE
    PUSH AX     ;SAVE REGISTERS
    PUSH BX
    PUSH CX
    PUSH DX
;IF AX<0
    OR AX,AX     ;AX<0
    JGE @END_IF1 
;THEN
    PUSH AX     ;SAVE NUMBER
    MOV DL,'-'
    MOV AH,2    
    INT 21H
    POP AX
    NEG AX      ;AX=-AX
@END_IF1:             
;GET DECIMAL DIGITS  
    XOR CX,CX   ;CX COUNTS DIGITS
    MOV BX,10D  ;BX HAS A DIVISOR
@REPEAT1:
    XOR DX,DX   ;PREPARE HIGHT WORD OF DIVIDEND
    DIV BX      ;AX=QUOTIENT,DX=REMAINDER    
    PUSH DX     ;SAVE REMAINDER ON STACK
    INC CX      ;COUNT=COUNT+1
;UNTIL    
    OR AX,AX    ;QUOTIENT=0?
    JNE @REPEAT1;NO,KEEP GOING
;CONVERT DIGITS TO CHARACTERS AND PRINT
    MOV AH,2
;FOR COUNT TIMES DO
@PRINT_LOOP:
    POP DX      ;DIGIT IN DL
    OR DL,30H   ;CONVERT TO CHARACTER
    INT 21H      ;PRINT DIGIT
    LOOP @PRINT_LOOP ;LOOP UNTIL DONE
;END FOR
    POP DX
    POP CX
    POP BX
    POP AX
    RET
OUTDEC ENDP                
    


;----------------------
MAIN PROC
    ; initialize DS
    MOV AX, @DATA
    MOV DS, AX 
    
    ;INPUT A NUMBER
    CALL INDEC
    PUSH AX         ;SAVE NUMBER
    ;MOVE CURSOR TO NEW LINE
    MOV AH,2
    MOV DL,0DH
    INT 21H
    MOV DL,0AH
    INT 21H
    ;OUTPUT THE NUMBER
    POP AX
    CALL OUTDEC
        
    DOS_EXIT:
    MOV AH, 4CH
    INT 21H
    MAIN ENDP
END MAIN
;AX<0
;PRINT A -SIGN
;AX<- AX'S 2'S COMPLEMENT
;END IF
;DIGIT<-DX DECIMAL REPRESENTATION
;CONVERT DIGIT->DH &
;PRINT              

ISPRIME PROC 
    
   ;DEC VALUE STORED IN AX
   MOV CX,AX-2
   MOV BL,1;LET IT'S PRIME
   MOV DX,0
   
   CMP AX,2
   JL NONPRIME
   JE PRIME   
   
CHECK_PRIME:    
    

LOOP CHECK_PRIME
    
   
   
PRIME:   
    MOV AH,9
    LEA DX,STR_PRIME   
    INT 21H
   
NONPRIME: 
    MOV AH,9
    LEA DX,STR_NONPRIME
    INT 21H
    
   
END ISPRIME   